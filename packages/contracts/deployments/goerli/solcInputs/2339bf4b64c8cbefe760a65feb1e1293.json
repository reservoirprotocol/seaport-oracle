{
  "language": "Solidity",
  "sources": {
    "src/interfaces/ZoneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ZoneParameters, Schema } from \"../lib/ConsiderationStructs.sol\";\n\ninterface ZoneInterface {\n    function validateOrder(\n        ZoneParameters calldata zoneParameters\n    ) external returns (bytes4 validOrderMagicValue);\n\n    function getSeaportMetadata()\n        external\n        view\n        returns (\n            string memory name,\n            Schema[] memory schemas // map to Seaport Improvement Proposal IDs\n        );\n}\n"
    },
    "src/lib/ConsiderationEnums.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// prettier-ignore\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n\n// prettier-ignore\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\n// prettier-ignore\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\n// prettier-ignore\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\n// prettier-ignore\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n\n    // 1: Items that must be received\n    CONSIDERATION\n}\n"
    },
    "src/lib/ConsiderationStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { OrderType, BasicOrderType, ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose \"identifierOrCriteria\"\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n *      enum; this represents both the usual order type as well as the \"route\"\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be provided to the zone if the\n *      order type is restricted and the zone is not the caller, or will be\n *      provided to the offerer as context for contract order types.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item's\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer's chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\n/**\n * @dev Zones and contract offerers can communicate which schemas they implement\n *      along with any associated metadata related to each schema.\n */\nstruct Schema {\n    uint256 id;\n    bytes metadata;\n}\n"
    },
    "src/zones/interfaces/SignedZoneControllerEventsAndErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @notice SignedZoneControllerEventsAndErrors contains errors and events\n *         related to deploying and managing new signed zones.\n */\ninterface SignedZoneControllerEventsAndErrors {\n    /**\n     * @dev Emit an event whenever a new zone is created.\n     *\n     * @param zoneAddress The address of the zone.\n     * @param zoneName    The name for the zone returned in\n     *                    getSeaportMetadata().\n     * @param apiEndpoint The API endpoint where orders for this zone can be\n     *                    signed.\n     * @param documentationURI The URI to the documentation describing the\n     *                         behavior of the contract.\n     *                    Request and response payloads are defined in SIP-7.\n     * @param salt        The salt used to deploy the zone.\n     */\n    event ZoneCreated(\n        address zoneAddress,\n        string zoneName,\n        string apiEndpoint,\n        string documentationURI,\n        bytes32 salt\n    );\n\n    /**\n     * @dev Emit an event whenever zone ownership is transferred.\n     *\n     * @param zone          The zone for which ownership has been\n     *                      transferred.\n     * @param previousOwner The previous owner of the zone.\n     * @param newOwner      The new owner of the zone.\n     */\n    event OwnershipTransferred(\n        address indexed zone,\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Emit an event whenever a zone owner registers a new potential\n     *      owner for that zone.\n     *\n     * @param newPotentialOwner The new potential owner of the zone.\n     */\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\n\n    /**\n     * @dev Emit an event when a signer has been updated.\n     */\n    event SignerUpdated(address signedZone, address signer, bool active);\n\n    /**\n     * @dev Revert with an error when attempting to update channels or transfer\n     *      ownership of a zone when the caller is not the owner of the\n     *      zone in question.\n     */\n    error CallerIsNotOwner(address zone);\n\n    /**\n     * @dev Revert with an error when the caller is not the owner or an active\n     *      signer of the signed zone in question.\n     */\n    error CallerIsNotOwnerOrSigner(address zone);\n\n    /**\n     * @dev Revert with an error when attempting to claim ownership of a zone\n     *      with a caller that is not the current potential owner for the\n     *      zone in question.\n     */\n    error CallerIsNotNewPotentialOwner(address zone);\n\n    /**\n     * @dev Revert with an error when attempting to create a new signed zone\n     *      using a salt where the first twenty bytes do not match the address\n     *      of the caller or are not set to zero.\n     */\n    error InvalidCreator();\n\n    /**\n     * @dev Revert with an error when attempting to create a new zone when no\n     *      initial owner address is supplied.\n     */\n    error InvalidInitialOwner();\n\n    /**\n     * @dev Revert with an error when attempting to set a new potential owner\n     *      that is already set.\n     */\n    error NewPotentialOwnerAlreadySet(address zone, address newPotentialOwner);\n\n    /**\n     * @dev Revert with an error when attempting to cancel ownership transfer\n     *      when no new potential owner is currently set.\n     */\n    error NoPotentialOwnerCurrentlySet(address zone);\n    /**\n     * @dev Revert with an error when attempting to register a new potential\n     *      owner and supplying the null address.\n     */\n    error NewPotentialOwnerIsZeroAddress(address zone);\n\n    /**\n     * @dev Revert with an error when attempting to interact with a zone that\n     *      does not yet exist.\n     */\n    error NoZone();\n\n    /**\n     * @dev Revert with an error if trying to add a signer that is\n     *      already active.\n     */\n    error SignerAlreadyAdded(address signer);\n\n    /**\n     * @dev Revert with an error if a new signer is the zero address.\n     */\n    error SignerCannotBeZeroAddress();\n\n    /**\n     * @dev Revert with an error if a removed signer is trying to be\n     *      reauthorized.\n     */\n    error SignerCannotBeReauthorized(address signer);\n\n    /**\n     * @dev Revert with an error if trying to remove a signer that is\n     *      not present.\n     */\n    error SignerNotPresent(address signer);\n\n    /**\n     * @dev Revert with an error when attempting to deploy a zone that is\n     *      currently deployed.\n     */\n    error ZoneAlreadyExists(address zone);\n}\n"
    },
    "src/zones/interfaces/SignedZoneControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title  SignedZoneControllerInterface\n * @author BCLeFevre\n * @notice SignedZoneControllerInterface enables the deploying of SignedZones.\n *         SignedZones are an implementation of SIP-7 that requires orders\n *         to be signed by an approved signer.\n *         https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md\n *\n */\ninterface SignedZoneControllerInterface {\n    /**\n     * @notice Deploy a SignedZone to a precomputed address.\n     *\n     * @param zoneName    The name for the zone returned in\n     *                    getSeaportMetadata().\n     * @param apiEndpoint The API endpoint where orders for this zone can be\n     *                    signed.\n     * @param documentationURI The URI to the documentation describing the\n     *                         behavior of the contract.\n     *                    Request and response payloads are defined in SIP-7.\n     * @param salt        The salt to be used to derive the zone address\n     * @param initialOwner The initial owner to set for the new zone.\n     *\n     * @return derivedAddress The derived address for the zone.\n     */\n    function createZone(\n        string memory zoneName,\n        string memory apiEndpoint,\n        string memory documentationURI,\n        address initialOwner,\n        bytes32 salt\n    ) external returns (address derivedAddress);\n\n    /**\n     * @notice Returns the active signers for the zone.\n     *\n     * @param signedZone The signed zone to get the active signers for.\n     *\n     * @return signers The active signers.\n     */\n    function getActiveSigners(address signedZone)\n        external\n        view\n        returns (address[] memory signers);\n\n    /**\n     * @notice Returns additional information about the zone.\n     *\n     * @param zone The zone to get the additional information for.\n     *\n     * @return domainSeparator  The domain separator used for signing.\n     * @return zoneName         The name of the zone.\n     * @return apiEndpoint      The API endpoint for the zone.\n     * @return substandards     The substandards supported by the zone.\n     * @return documentationURI The documentation URI for the zone.\n     */\n    function getAdditionalZoneInformation(address zone)\n        external\n        view\n        returns (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        );\n\n    /**\n     * @notice Update the API endpoint returned by the supplied zone.\n     *         Only the owner or an active signer can call this function.\n     *\n     * @param signedZone    The signed zone to update the API endpoint for.\n     * @param newApiEndpoint The new API endpoint.\n     */\n    function updateAPIEndpoint(\n        address signedZone,\n        string calldata newApiEndpoint\n    ) external;\n\n    /**\n     * @notice Update the signer for a given signed zone.\n     *\n     * @param signedZone The signed zone to update the signer for.\n     * @param signer     The signer to update.\n     * @param active     If the signer should be active or not.\n     */\n    function updateSigner(\n        address signedZone,\n        address signer,\n        bool active\n    ) external;\n\n    /**\n     * @notice Initiate zone ownership transfer by assigning a new potential\n     *         owner for the given zone. Once set, the new potential owner\n     *         may call `acceptOwnership` to claim ownership of the zone.\n     *         Only the owner of the zone in question may call this function.\n     *\n     * @param zone The zone for which to initiate ownership transfer.\n     * @param newPotentialOwner The new potential owner of the zone.\n     */\n    function transferOwnership(address zone, address newPotentialOwner)\n        external;\n\n    /**\n     * @notice Clear the currently set potential owner, if any, from a zone.\n     *         Only the owner of the zone in question may call this function.\n     *\n     * @param zone The zone for which to cancel ownership transfer.\n     */\n    function cancelOwnershipTransfer(address zone) external;\n\n    /**\n     * @notice Accept ownership of a supplied zone. Only accounts that the\n     *         current owner has set as the new potential owner may call this\n     *         function.\n     *\n     * @param zone The zone for which to accept ownership.\n     */\n    function acceptOwnership(address zone) external;\n\n    /**\n     * @notice Retrieve the current owner of a deployed zone.\n     *\n     * @param zone The zone for which to retrieve the associated owner.\n     *\n     * @return owner The owner of the supplied zone.\n     */\n    function ownerOf(address zone) external view returns (address owner);\n\n    /**\n     * @notice Retrieve the potential owner, if any, for a given zone. The\n     *         current owner may set a new potential owner via\n     *         `transferOwnership` and that owner may then accept ownership of\n     *         the zone in question via `acceptOwnership`.\n     *\n     * @param zone The zone for which to retrieve the potential owner.\n     *\n     * @return potentialOwner The potential owner, if any, for the zone.\n     */\n    function getPotentialOwner(address zone)\n        external\n        view\n        returns (address potentialOwner);\n\n    /**\n     * @notice Derive the zone address associated with a salt.\n     *\n     * @param salt        The salt to be used to derive the zone address\n     *\n     * @return derivedAddress The derived address of the signed zone.\n     */\n    function getZone(bytes32 salt)\n        external\n        view\n        returns (address derivedAddress);\n}\n"
    },
    "src/zones/interfaces/SignedZoneEventsAndErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @notice SignedZoneEventsAndErrors contains errors and events\n *         related to zone interaction.\n */\ninterface SignedZoneEventsAndErrors {\n    /**\n     * @dev Emit an event when a new signer is added.\n     */\n    event SignerAdded(address signer);\n\n    /**\n     * @dev Emit an event when a signer is removed.\n     */\n    event SignerRemoved(address signer);\n\n    /**\n     * @dev Revert with an error if msg.sender is not the owner\n     *      or an active signer.\n     */\n    error OnlyOwnerOrActiveSigner();\n\n    /**\n     * @dev Revert with an error when the signature has expired.\n     */\n    error SignatureExpired(uint256 expiration, bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to update the signers of a\n     *      the zone from a caller that is not the zone's controller.\n     */\n    error InvalidController();\n\n    /**\n     * @dev Revert with an error if supplied order extraData is an invalid\n     *      length.\n     */\n    error InvalidExtraDataLength(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error if the supplied order extraData does not\n     *      support the zone's SIP6 version.\n     */\n    error InvalidSIP6Version(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error if the supplied order extraData does not\n     *      support the zone's substandard requirements.\n     */\n    error InvalidSubstandardSupport(\n        string reason,\n        uint256 substandardVersion,\n        bytes32 orderHash\n    );\n\n    /**\n     * @dev Revert with an error if the supplied order extraData does not\n     *      support the zone's substandard version.\n     */\n    error InvalidSubstandardVersion(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error if the fulfiller does not match.\n     */\n    error InvalidFulfiller(\n        address expectedFulfiller,\n        address actualFulfiller,\n        bytes32 orderHash\n    );\n\n    /**\n     * @dev Revert with an error if the consideration does not match.\n     */\n    error InvalidConsideration(\n        uint256 expectedConsiderationHash,\n        uint256 actualConsiderationHash,\n        bytes32 orderHash\n    );\n\n    /**\n     * @dev Revert with an error if the zone parameter encoding is invalid.\n     */\n    error InvalidZoneParameterEncoding();\n\n    /**\n     * @dev Revert with an error when an order is signed with a signer\n     *      that is not active.\n     */\n    error SignerNotActive(address signer, bytes32 orderHash);\n}\n"
    },
    "src/zones/interfaces/SignedZoneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title  SignedZone\n * @author ryanio, BCLeFevre\n * @notice SignedZone is an implementation of SIP-7 that requires orders\n *         to be signed by an approved signer.\n *         https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md\n *\n */\ninterface SignedZoneInterface {\n    /**\n     * @notice Update the active status of a signer.\n     *\n     * @param signer The signer address to update.\n     * @param active The new active status of the signer.\n     */\n    function updateSigner(address signer, bool active) external;\n\n    /**\n     * @notice Returns the active signers for the zone.\n     *\n     * @return signers The active signers.\n     */\n    function getActiveSigners()\n        external\n        view\n        returns (address[] memory signers);\n}\n"
    },
    "src/zones/interfaces/SIP5Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Schema } from \"../../lib/ConsiderationStructs.sol\";\n\n/**\n * @dev SIP-5: Contract Metadata Interface for Seaport Contracts\n *      https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-5.md\n */\ninterface SIP5Interface {\n    /**\n     * @dev An event that is emitted when a SIP-5 compatible contract is deployed.\n     */\n    event SeaportCompatibleContractDeployed();\n\n    /**\n     * @dev Returns Seaport metadata for this contract, returning the\n     *      contract name and supported schemas.\n     *\n     * @return name    The contract name\n     * @return schemas The supported SIPs\n     */\n    function getSeaportMetadata()\n        external\n        view\n        returns (string memory name, Schema[] memory schemas);\n}\n"
    },
    "src/zones/lib/SignedZoneConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @dev ECDSA signature offsets.\nuint256 constant ECDSA_MaxLength = 65;\nuint256 constant ECDSA_signature_s_offset = 0x40;\nuint256 constant ECDSA_signature_v_offset = 0x60;\n\n/// @dev Helpers for memory offsets.\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\nuint256 constant FourWords = 0x80;\nuint256 constant FiveWords = 0xa0;\nuint256 constant Signature_lower_v = 27;\nuint256 constant MaxUint8 = 0xff;\nbytes32 constant EIP2098_allButHighestBitMask = (\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n);\nuint256 constant Ecrecover_precompile = 1;\nuint256 constant Ecrecover_args_size = 0x80;\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant Slot0x80 = 0x80;\n\n/// @dev The EIP-712 digest offsets.\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_SignedOrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\nuint256 constant EIP_712_PREFIX = (\n    0x1901000000000000000000000000000000000000000000000000000000000000\n);\n\n/*\n *  error InvalidController()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidController_error_selector = 0x6d5769be;\nuint256 constant InvalidController_error_length = 0x04;\n\n/*\n *  error InvalidFulfiller(address expectedFulfiller, address actualFulfiller, bytes32 orderHash)\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: expectedFulfiller\n *    - 0x40: actualFullfiller\n *    - 0x60: orderHash\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant InvalidFulfiller_error_selector = 0x1bcf9bb7;\nuint256 constant InvalidFulfiller_error_expectedFulfiller_ptr = 0x20;\nuint256 constant InvalidFulfiller_error_actualFulfiller_ptr = 0x40;\nuint256 constant InvalidFulfiller_error_orderHash_ptr = 0x60;\nuint256 constant InvalidFulfiller_error_length = 0x64;\n\n/*\n *  error InvalidConsideration(uint256 expectedConsideration, uint256 actualConsideration, bytes32 orderHash)\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: expectedConsideration\n *    - 0x40: actualConsideration\n *    - 0x60: orderHash\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant InvalidConsideration_error_selector = 0x59cb96d1;\nuint256 constant InvalidConsideration_error_expectedConsideration_ptr = 0x20;\nuint256 constant InvalidConsideration_error_actualConsideration_ptr = 0x40;\nuint256 constant InvalidConsideration_error_orderHash_ptr = 0x60;\nuint256 constant InvalidConsideration_error_length = 0x64;\n\n/*\n *  error InvalidZoneParameterEncoding()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidZoneParameterEncoding_error_selector = 0x46d5d895;\nuint256 constant InvalidZoneParameterEncoding_error_length = 0x04;\n\n/*\n * error InvalidExtraDataLength()\n *   - Defined in SignedZoneEventsAndErrors.sol\n * Memory layout:\n *   - 0x00: Left-padded selector (data begins at 0x1c)\n *   - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidExtraDataLength_error_selector = 0xd232fd2c;\nuint256 constant InvalidExtraDataLength_error_orderHash_ptr = 0x20;\nuint256 constant InvalidExtraDataLength_error_length = 0x24;\nuint256 constant InvalidExtraDataLength_epected_length = 0x7e;\n\nuint256 constant ExtraData_expiration_offset = 0x35;\nuint256 constant ExtraData_substandard_version_byte_offset = 0x7d;\n/*\n *  error InvalidSIP6Version()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidSIP6Version_error_selector = 0x64115774;\nuint256 constant InvalidSIP6Version_error_orderHash_ptr = 0x20;\nuint256 constant InvalidSIP6Version_error_length = 0x24;\n\n/*\n *  error InvalidSubstandardVersion()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidSubstandardVersion_error_selector = 0x26787999;\nuint256 constant InvalidSubstandardVersion_error_orderHash_ptr = 0x20;\nuint256 constant InvalidSubstandardVersion_error_length = 0x24;\n\n/*\n *  error InvalidSubstandardSupport()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: reason\n *    - 0x40: substandardVersion\n *    - 0x60: orderHash\n * Revert buffer is memory[0x1c:0xe0]\n */\nuint256 constant InvalidSubstandardSupport_error_selector = 0x2be76224;\nuint256 constant InvalidSubstandardSupport_error_reason_offset_ptr = 0x20;\nuint256 constant InvalidSubstandardSupport_error_substandard_version_ptr = 0x40;\nuint256 constant InvalidSubstandardSupport_error_orderHash_ptr = 0x60;\nuint256 constant InvalidSubstandardSupport_error_reason_length_ptr = 0x80;\nuint256 constant InvalidSubstandardSupport_error_reason_ptr = 0xa0;\nuint256 constant InvalidSubstandardSupport_error_reason_2_ptr = 0xc0;\nuint256 constant InvalidSubstandardSupport_error_length = 0xc4;\n\n/*\n * error SignatureExpired()\n *   - Defined in SignedZoneEventsAndErrors.sol\n * Memory layout:\n *   - 0x00: Left-padded selector (data begins at 0x1c)\n *   - 0x20: expiration\n *   - 0x40: orderHash\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant SignatureExpired_error_selector = 0x16546071;\nuint256 constant SignatureExpired_error_expiration_ptr = 0x20;\nuint256 constant SignatureExpired_error_orderHash_ptr = 0x40;\nuint256 constant SignatureExpired_error_length = 0x44;\n\n// Zone parameter calldata pointers\nuint256 constant Zone_parameters_cdPtr = 0x04;\nuint256 constant Zone_parameters_fulfiller_cdPtr = 0x44;\nuint256 constant Zone_consideration_head_cdPtr = 0xa4;\nuint256 constant Zone_extraData_cdPtr = 0xc4;\n\n// Zone parameter memory pointers\nuint256 constant Zone_parameters_ptr = 0x20;\n\n// Zone parameter offsets\nuint256 constant Zone_parameters_offset = 0x24;\nuint256 constant expectedFulfiller_offset = 0x45;\nuint256 constant actualConsideration_offset = 0x84;\nuint256 constant expectedConsideration_offset = 0xa2;\n"
    },
    "src/zones/SignedZone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    ZoneParameters,\n    Schema,\n    ReceivedItem\n} from \"../lib/ConsiderationStructs.sol\";\n\nimport { ZoneInterface } from \"../interfaces/ZoneInterface.sol\";\n\nimport {\n    SignedZoneEventsAndErrors\n} from \"./interfaces/SignedZoneEventsAndErrors.sol\";\n\nimport { SIP5Interface } from \"./interfaces/SIP5Interface.sol\";\n\nimport {\n    SignedZoneControllerInterface\n} from \"./interfaces/SignedZoneControllerInterface.sol\";\n\nimport \"./lib/SignedZoneConstants.sol\";\n\n/**\n * @title  SignedZone\n * @author ryanio, BCLeFevre\n * @custom:modifiedby Tony Snark\n * @notice SignedZone is an implementation of SIP-7 that requires orders\n *         to be signed by an approved signer.\n *         https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md\n *\n *         Modification:\n *         Removes support for SIP7 sub-standard 1.\n *         Adds support for SIP7 sub-standard 3.\n */\ncontract SignedZone is SignedZoneEventsAndErrors, ZoneInterface, SIP5Interface {\n    /// @dev The zone's controller that is set during deployment.\n    address private immutable _controller;\n\n    /// @dev The authorized signers, and if they are active\n    mapping(address => bool) private _signers;\n\n    /// @dev The EIP-712 digest parameters.\n    bytes32 internal immutable _NAME_HASH = keccak256(bytes(\"SignedZone\"));\n    bytes32 internal immutable _VERSION_HASH = keccak256(bytes(\"1.0.0\"));\n    // prettier-ignore\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH = keccak256(\n          abi.encodePacked(\n            \"EIP712Domain(\",\n                \"string name,\",\n                \"string version,\",\n                \"uint256 chainId,\",\n                \"address verifyingContract\",\n            \")\"\n          )\n        );\n    // prettier-ignore\n    bytes32 internal immutable _SIGNED_ORDER_TYPEHASH = keccak256(\n          abi.encodePacked(\n            \"SignedOrder(\",\n                \"address fulfiller,\",\n                \"uint64 expiration,\",\n                \"bytes32 orderHash,\",\n                \"bytes context\",\n            \")\"\n          )\n        );\n\n    bytes public constant CONSIDERATION_BYTES =\n        // prettier-ignore\n        abi.encodePacked(\n              \"Consideration(\",\n                  \"ReceivedItem[] consideration\",\n              \")\"\n        );\n\n    bytes public constant RECEIVED_ITEM_BYTES =\n        // prettier-ignore\n        abi.encodePacked(\n              \"ReceivedItem(\",\n                  \"uint8 itemType,\",\n                  \"address token,\",\n                  \"uint256 identifier,\",\n                  \"uint256 amount,\",\n                  \"address recipient\",\n              \")\"\n        );\n\n    bytes32 public constant RECEIVED_ITEM_HASHTYPE =\n        keccak256(RECEIVED_ITEM_BYTES);\n\n    bytes32 public constant CONSIDERATION_HASHTYPE =\n        keccak256(abi.encodePacked(CONSIDERATION_BYTES, RECEIVED_ITEM_BYTES));\n\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    /**\n     * @notice Constructor to deploy the contract.\n     */\n    constructor() {\n        // Set the deployer as the controller.\n        _controller = msg.sender;\n\n        // Derive and set the domain separator.\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n\n        // Emit an event to signal a SIP-5 contract has been deployed.\n        emit SeaportCompatibleContractDeployed();\n    }\n\n    /**\n     * @notice Check if a given order including extraData is currently valid.\n     *\n     * @dev This function is called by Seaport whenever any extraData is\n     *      provided by the caller.\n     *\n     * @return validOrderMagicValue A magic value indicating if the order is\n     *                              currently valid.\n     */\n    function validateOrder(ZoneParameters calldata zoneParameters)\n        public\n        view\n        virtual\n        override\n        returns (bytes4 validOrderMagicValue)\n    {\n        // Check Zone parameters validity.\n        _assertValidZoneParameters();\n\n        // Put the extraData and orderHash on the stack for cheaper access.\n        bytes calldata extraData = zoneParameters.extraData;\n        bytes32 orderHash = zoneParameters.orderHash;\n        uint256 considerationLength;\n        // Declare a variable to hold the expiration.\n        uint64 expiration;\n\n        // Validate the extraData.\n        assembly {\n            // Get the length of the extraData.\n            let extraDataPtr := add(0x24, calldataload(Zone_extraData_cdPtr))\n            let extraDataLength := calldataload(extraDataPtr)\n\n            if iszero(\n                eq(extraDataLength, InvalidExtraDataLength_epected_length)\n            ) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidExtraDataLength_error_selector)\n                mstore(InvalidExtraDataLength_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidExtraDataLength(bytes32)\", orderHash)\n                // )\n                revert(0x1c, InvalidExtraDataLength_error_length)\n            }\n\n            // extraData bytes 0-1: SIP-6 version byte (MUST be 0x00)\n            let versionByte := shr(248, calldataload(add(extraDataPtr, 0x20)))\n\n            if iszero(eq(versionByte, 0x00)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidSIP6Version_error_selector)\n                mstore(InvalidSIP6Version_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidSIP6Version(bytes32)\", orderHash)\n                // )\n                revert(0x1c, InvalidSIP6Version_error_length)\n            }\n\n            // extraData bytes 93-94: Substandard #1 (MUST be 0x00)\n            let subStandardVersionByte := shr(\n                248,\n                calldataload(\n                    add(extraDataPtr, ExtraData_substandard_version_byte_offset)\n                )\n            )\n\n            if iszero(eq(subStandardVersionByte, 0x00)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidSubstandardVersion_error_selector)\n                mstore(InvalidSubstandardVersion_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidSubstandardVersion(bytes32)\", orderHash)\n                // )\n                revert(0x1c, InvalidSubstandardVersion_error_length)\n            }\n\n            // extraData bytes 21-29: expiration timestamp (uint64)\n            expiration := shr(\n                192,\n                calldataload(add(extraDataPtr, ExtraData_expiration_offset))\n            )\n            // Revert if expired.\n            if lt(expiration, timestamp()) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, SignatureExpired_error_selector)\n                mstore(SignatureExpired_error_expiration_ptr, expiration)\n                mstore(SignatureExpired_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"SignatureExpired(uint256, bytes32)\", expiration orderHash)\n                // )\n                revert(0x1c, SignatureExpired_error_length)\n            }\n\n            // // Get the length of the consideration array.\n            considerationLength := calldataload(\n                add(0x24, calldataload(Zone_consideration_head_cdPtr))\n            )\n        }\n\n        // extraData bytes 29-93: signature\n        // (strictly requires 64 byte compact sig, EIP-2098)\n        bytes calldata signature = extraData[29:93];\n\n        // extraData bytes 93-end: context (optional, variable length)\n        bytes calldata context = extraData[93:];\n\n        // Check the validity of the Substandard #1 extraData and get the\n        // expected fulfiller address.\n        address expectedFulfiller = _getExpectedFulfiller(orderHash);\n\n        // Check the validity of the Substandard #1 extraData and get the\n        // expected fulfiller address.\n        if (considerationLength > 0) {\n            _assertValidSubstandard(\n                _deriveConsiderationHash(zoneParameters.consideration),\n                orderHash\n            );\n        }\n\n        // Derive the signedOrder hash.\n        bytes32 signedOrderHash = _deriveSignedOrderHash(\n            expectedFulfiller,\n            expiration,\n            orderHash,\n            context\n        );\n\n        // Derive the EIP-712 digest using the domain separator and signedOrder\n        // hash.\n        bytes32 digest = _deriveEIP712Digest(\n            _domainSeparator(),\n            signedOrderHash\n        );\n\n        // Recover the signer address from the digest and signature.\n        address recoveredSigner = _recoverSigner(digest, signature);\n\n        // Revert if the signer is not active.\n        if (!_signers[recoveredSigner]) {\n            revert SignerNotActive(recoveredSigner, orderHash);\n        }\n        // Return the selector of validateOrder as the magic value.\n        validOrderMagicValue = ZoneInterface.validateOrder.selector;\n    }\n\n    /**\n     * @dev Returns Seaport metadata for this contract, returning the\n     *      contract name and supported schemas.\n     *\n     * @return name The contract name\n     * @return schemas  The supported SIPs\n     */\n    function getSeaportMetadata()\n        external\n        view\n        override(SIP5Interface, ZoneInterface)\n        returns (string memory name, Schema[] memory schemas)\n    {\n        // Return the supported SIPs.\n        schemas = new Schema[](1);\n        schemas[0].id = 7;\n\n        // Get the SIP-7 information.\n        (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        ) = _sip7Information();\n\n        // Return the zone name.\n        name = zoneName;\n\n        // Encode the SIP-7 information.\n        schemas[0].metadata = abi.encode(\n            domainSeparator,\n            apiEndpoint,\n            substandards,\n            documentationURI\n        );\n    }\n\n    /**\n     * @notice The fallback function is used as a dispatcher for the\n     *         `updateSigner`, `getActiveSigners` and `supportsInterface`\n     *         functions.\n     */\n    // prettier-ignore\n    fallback(bytes calldata) external payable returns (bytes memory output) {\n        // Get the function selector.\n        bytes4 selector = msg.sig;\n\n        if (selector == 0xf460590b) {\n            // updateSigner(address,bool)\n\n            // Get the signer, and active status.\n            address signer = abi.decode(msg.data[4:], (address));\n            bool active = abi.decode(msg.data[36:], (bool));\n\n            // Call to update the signer.\n            _updateSigner(signer, active);\n        } else if (selector == 0xa784b80c) {\n            // getActiveSigners()\n\n            // Call the internal function to get the active signers.\n            return abi.encode(_getActiveSigners());\n        } else if (selector == 0x01ffc9a7) {\n            // supportsInterface(bytes4)\n\n            // Get the interface ID.\n            bytes4 interfaceId = abi.decode(msg.data[4:], (bytes4));\n\n            // Call the internal function to determine if the interface is\n            // supported.\n            return abi.encode(_supportsInterface(interfaceId));\n        }\n    }\n\n    /**\n     * @notice Add or remove a signer to the zone.\n     *         Only the controller can call this function.\n     *\n     * @param signer The signer address to add or remove.\n     */\n    function _updateSigner(address signer, bool active) internal {\n        // Only the controller can call this function.\n        _assertCallerIsController();\n        // Add or remove the signer.\n        active ? _addSigner(signer) : _removeSigner(signer);\n    }\n\n    /**\n     * @notice Add a new signer to the zone.\n     *         Only the controller or an active signer can call this function.\n     *\n     * @param signer The new signer address to add.\n     */\n    function _addSigner(address signer) internal {\n        // Set the signer info.\n        _signers[signer] = true;\n        // Emit an event that the signer was added.\n        emit SignerAdded(signer);\n    }\n\n    /**\n     * @notice Remove an active signer from the zone.\n     *         Only the controller or an active signer can call this function.\n     *\n     * @param signer The signer address to remove.\n     */\n    function _removeSigner(address signer) internal {\n        // Set the signer's active status to false.\n        _signers[signer] = false;\n\n        // Emit an event that the signer was removed.\n        emit SignerRemoved(signer);\n    }\n\n    /**\n     * @notice Returns the active signers for the zone.\n     *\n     * @return signers The active signers.\n     */\n    function _getActiveSigners()\n        internal\n        view\n        returns (address[] memory signers)\n    {\n        // Return the active signers for the zone by calling the controller.\n        signers = SignedZoneControllerInterface(_controller).getActiveSigners(\n            address(this)\n        );\n    }\n\n    /**\n     * @notice Returns whether the interface is supported.\n     *\n     * @param interfaceId The interface id to check against.\n     */\n    function _supportsInterface(bytes4 interfaceId)\n        internal\n        pure\n        returns (bool supportsInterface)\n    {\n        // Determine if the interface is supported.\n        supportsInterface =\n            interfaceId == type(SIP5Interface).interfaceId || // SIP-5\n            interfaceId == type(ZoneInterface).interfaceId || // ZoneInterface\n            interfaceId == 0x01ffc9a7; // ERC-165\n    }\n\n    /**\n     * @notice Internal call to return the signing information, substandards,\n     *         and documentation about the zone.\n     *\n     * @return domainSeparator  The domain separator used for signing.\n     * @return zoneName         The zone name.\n     * @return apiEndpoint      The API endpoint for the zone.\n     * @return substandards     The substandards supported by the zone.\n     * @return documentationURI The documentation URI for the zone.\n     */\n    function _sip7Information()\n        internal\n        view\n        returns (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        )\n    {\n        // Return the SIP-7 information.\n        domainSeparator = _domainSeparator();\n\n        // Get the SIP-7 information from the controller.\n        (\n            ,\n            zoneName,\n            apiEndpoint,\n            substandards,\n            documentationURI\n        ) = SignedZoneControllerInterface(_controller)\n            .getAdditionalZoneInformation(address(this));\n    }\n\n    /**\n     * @dev Derive the signedOrder hash from the orderHash and expiration.\n     *\n     * @param fulfiller  The expected fulfiller address.\n     * @param expiration The signature expiration timestamp.\n     * @param orderHash  The order hash.\n     * @param context    The optional variable-length context.\n     *\n     * @return signedOrderHash The signedOrder hash.\n     *\n     */\n    function _deriveSignedOrderHash(\n        address fulfiller,\n        uint64 expiration,\n        bytes32 orderHash,\n        bytes calldata context\n    ) internal view returns (bytes32 signedOrderHash) {\n        // Derive the signed order hash.\n        signedOrderHash = keccak256(\n            abi.encode(\n                _SIGNED_ORDER_TYPEHASH,\n                fulfiller,\n                expiration,\n                orderHash,\n                keccak256(context)\n            )\n        );\n    }\n\n    /**\n     * @dev Internal view function to return the signer of a signature.\n     *\n     * @param digest    The digest to verify the signature against.\n     * @param signature A signature from the signer indicating that the order\n     *                  has been approved.\n     *\n     * @return recoveredSigner The recovered signer.\n     */\n    function _recoverSigner(bytes32 digest, bytes memory signature)\n        internal\n        view\n        returns (address recoveredSigner)\n    {\n        // Utilize assembly to perform optimized signature verification check.\n        assembly {\n            // Ensure that first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Declare value for v signature parameter.\n            let v\n\n            // Get the length of the signature.\n            let signatureLength := mload(signature)\n\n            // Get the pointer to the value preceding the signature length.\n            // This will be used for temporary memory overrides - either the\n            // signature head for isValidSignature or the digest for ecrecover.\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\n\n            // Cache the current value behind the signature to restore it later.\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\n\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\n            {\n                // Take the difference between the max ECDSA signature length\n                // and the actual signature length. Overflow desired for any\n                // values > 65. If the diff is not 0 or 1, it is not a valid\n                // ECDSA signature - move on to EIP1271 check.\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\n\n                // If diff is 0 or 1, it may be an ECDSA signature.\n                // Try to recover signer.\n                if iszero(gt(lenDiff, 1)) {\n                    // Read the signature `s` value.\n                    let originalSignatureS := mload(\n                        add(signature, ECDSA_signature_s_offset)\n                    )\n\n                    // Read the first byte of the word after `s`. If the\n                    // signature is 65 bytes, this will be the real `v` value.\n                    // If not, it will need to be modified - doing it this way\n                    // saves an extra condition.\n                    v := byte(\n                        0,\n                        mload(add(signature, ECDSA_signature_v_offset))\n                    )\n\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\n                    if lenDiff {\n                        // Extract yParity from highest bit of vs and add 27 to\n                        // get v.\n                        v := add(\n                            shr(MaxUint8, originalSignatureS),\n                            Signature_lower_v\n                        )\n\n                        // Extract canonical s from vs, all but the highest bit.\n                        // Temporarily overwrite the original `s` value in the\n                        // signature.\n                        mstore(\n                            add(signature, ECDSA_signature_s_offset),\n                            and(\n                                originalSignatureS,\n                                EIP2098_allButHighestBitMask\n                            )\n                        )\n                    }\n                    // Temporarily overwrite the signature length with `v` to\n                    // conform to the expected input for ecrecover.\n                    mstore(signature, v)\n\n                    // Temporarily overwrite the word before the length with\n                    // `digest` to conform to the expected input for ecrecover.\n                    mstore(wordBeforeSignaturePtr, digest)\n\n                    // Attempt to recover the signer for the given signature. Do\n                    // not check the call status as ecrecover will return a null\n                    // address if the signature is invalid.\n                    pop(\n                        staticcall(\n                            gas(),\n                            Ecrecover_precompile, // Call ecrecover precompile.\n                            wordBeforeSignaturePtr, // Use data memory location.\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\n                            0, // Write result to scratch space.\n                            OneWord // Provide size of returned result.\n                        )\n                    )\n\n                    // Restore cached word before signature.\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n\n                    // Restore cached signature length.\n                    mstore(signature, signatureLength)\n\n                    // Restore cached signature `s` value.\n                    mstore(\n                        add(signature, ECDSA_signature_s_offset),\n                        originalSignatureS\n                    )\n\n                    // Read the recovered signer from the buffer given as return\n                    // space for ecrecover.\n                    recoveredSigner := mload(0)\n                }\n            }\n\n            // Restore the cached values overwritten by selector, digest and\n            // signature head.\n            mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n        }\n    }\n\n    /**\n     * @dev Internal view function to get the EIP-712 domain separator. If the\n     *      chainId matches the chainId set on deployment, the cached domain\n     *      separator will be returned; otherwise, it will be derived from\n     *      scratch.\n     *\n     * @return The domain separator.\n     */\n    function _domainSeparator() internal view returns (bytes32) {\n        // prettier-ignore\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return domainSeparator The derived domain separator.\n     */\n    function _deriveDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\n        bytes32 nameHash = _NAME_HASH;\n        bytes32 versionHash = _VERSION_HASH;\n\n        // Leverage scratch space and other memory to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Retrieve value at 0x80; it will also be replaced afterwards.\n            let slot0x80 := mload(Slot0x80)\n\n            // Place typehash, name hash, and version hash at start of memory.\n            mstore(0, typehash)\n            mstore(OneWord, nameHash)\n            mstore(TwoWords, versionHash)\n\n            // Place chainId in the next memory location.\n            mstore(ThreeWords, chainid())\n\n            // Place the address of this contract in the next memory location.\n            mstore(FourWords, address())\n\n            // Hash relevant region of memory to derive the domain separator.\n            domainSeparator := keccak256(0, FiveWords)\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n\n            // Restore the value at 0x80.\n            mstore(Slot0x80, slot0x80)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param domainSeparator The domain separator.\n     * @param signedOrderHash The signedOrder hash.\n     *\n     * @return digest The digest hash.\n     */\n    function _deriveEIP712Digest(\n        bytes32 domainSeparator,\n        bytes32 signedOrderHash\n    ) internal pure returns (bytes32 digest) {\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the signed order hash in scratch space, spilling into the\n            // first two bytes of the free memory pointer  this should never be\n            // set as memory cannot be expanded to that size, and will be\n            // zeroed out after the hash is performed.\n            mstore(EIP712_SignedOrderHash_offset, signedOrderHash)\n\n            // Hash the relevant region\n            digest := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_SignedOrderHash_offset, 0)\n        }\n    }\n\n    /**\n     * @dev Private view function to revert if the caller is not the\n     *      controller.\n     */\n    function _assertCallerIsController() internal view {\n        // Get the controller address to use in the assembly block.\n        address controller = _controller;\n\n        assembly {\n            // Revert if the caller is not the controller.\n            if iszero(eq(caller(), controller)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidController_error_selector)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidController()\")\n                // )\n                revert(0x1c, InvalidController_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for the\n     *      dyanamic type in ZoneParameters. This ensures that functions using\n     *      the calldata object normally will be using the same data as the\n     *      assembly functions and that values that are bound to a given range\n     *      are within that range.\n     */\n    function _assertValidZoneParameters() internal pure {\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Zone parameters struct offset == 0x20\n             */\n\n            // Zone parameters at calldata 0x04 must have offset of 0x20.\n            if iszero(\n                eq(calldataload(Zone_parameters_cdPtr), Zone_parameters_ptr)\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode), mem[28:32] = selector\n                mstore(0, InvalidZoneParameterEncoding_error_selector)\n                // revert(abi.encodeWithSignature(\"InvalidZoneParameterEncoding()\"))\n                revert(0x1c, InvalidZoneParameterEncoding_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the context argument for the\n     *      supplied extra data follows the substandard #1 format. Returns the\n     *      expected fulfiller of the order for deriving the signed order hash.\n     *\n     * @param orderHash The order hash.\n     *\n     * @return expectedFulfiller The expected fulfiller of the order.\n     */\n    function _getExpectedFulfiller(bytes32 orderHash)\n        internal\n        pure\n        returns (address expectedFulfiller)\n    {\n        // Revert if the expected fulfiller is not the zero address and does\n        // not match the actual fulfiller\n        assembly {\n            // Get the actual fulfiller.\n            let actualFulfiller := calldataload(Zone_parameters_fulfiller_cdPtr)\n            let extraDataPtr := calldataload(Zone_extraData_cdPtr)\n\n            // Get the expected fulfiller.\n            expectedFulfiller := shr(\n                96,\n                calldataload(add(expectedFulfiller_offset, extraDataPtr))\n            )\n\n            // Revert if expected fulfiller is not the zero address and does\n            // not match the actual fulfiller.\n            if and(\n                iszero(iszero(expectedFulfiller)),\n                iszero(eq(expectedFulfiller, actualFulfiller))\n            ) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidFulfiller_error_selector)\n                mstore(\n                    InvalidFulfiller_error_expectedFulfiller_ptr,\n                    expectedFulfiller\n                )\n                mstore(\n                    InvalidFulfiller_error_actualFulfiller_ptr,\n                    actualFulfiller\n                )\n                mstore(InvalidFulfiller_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidFulfiller(address,address,bytes32)\", expectedFulfiller, actualFulfiller, orderHash)\n                // )\n                revert(0x1c, InvalidFulfiller_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the context argument for the\n     *      supplied extra data follows the substandard #1 format. Returns the\n     *      expected fulfiller of the order for deriving the signed order hash.\n     *\n     */\n    function _assertValidSubstandard(\n        bytes32 considerationHash,\n        bytes32 orderHash\n    ) internal pure {\n        // identifier does not match the actual consideration.\n        assembly {\n            let extraDataPtr := calldataload(Zone_extraData_cdPtr)\n            let considerationPtr := calldataload(Zone_consideration_head_cdPtr)\n            // Get the actual consideration.\n            let actualConsideration := calldataload(\n                add(actualConsideration_offset, considerationPtr)\n            )\n\n            // Get the expected consideration.\n            let expectedConsiderationHash := calldataload(\n                add(expectedConsideration_offset, extraDataPtr) //TODO rename\n            )\n            // Revert if expected consideration item does not match the actual\n            // consideration item.\n            if iszero(eq(considerationHash, expectedConsiderationHash)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidConsideration_error_selector)\n                mstore(\n                    InvalidConsideration_error_expectedConsideration_ptr,\n                    expectedConsiderationHash\n                )\n                mstore(\n                    InvalidConsideration_error_actualConsideration_ptr,\n                    actualConsideration\n                )\n                mstore(InvalidConsideration_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidConsideration(uint256,uint256,bytes32)\", expectedConsideration, actualConsideration, orderHash)\n                // )\n                revert(0x1c, InvalidConsideration_error_length)\n            }\n        }\n    }\n\n    /// @dev Calculates consideration hash\n    function _deriveConsiderationHash(ReceivedItem[] calldata consideration)\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 numberOfItems = consideration.length;\n        bytes32[] memory considerationHashes = new bytes32[](numberOfItems);\n        for (uint256 i; i < numberOfItems; ) {\n            considerationHashes[i] = _deriveReceivedItemHash(consideration[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return\n            keccak256(\n                abi.encode(\n                    CONSIDERATION_HASHTYPE,\n                    keccak256(abi.encodePacked(considerationHashes))\n                )\n            );\n    }\n\n    /// @dev Calculates consideration item hash\n    function _deriveReceivedItemHash(ReceivedItem calldata receivedItem)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    RECEIVED_ITEM_HASHTYPE,\n                    receivedItem.itemType,\n                    receivedItem.token,\n                    receivedItem.identifier,\n                    receivedItem.amount,\n                    receivedItem.recipient\n                )\n            );\n    }\n}\n"
    },
    "src/zones/SignedZoneController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { SignedZone } from \"./SignedZone.sol\";\n\nimport { SignedZoneInterface } from \"./interfaces/SignedZoneInterface.sol\";\n\nimport {\n    SignedZoneControllerInterface\n} from \"./interfaces/SignedZoneControllerInterface.sol\";\n\nimport {\n    SignedZoneControllerEventsAndErrors\n} from \"./interfaces/SignedZoneControllerEventsAndErrors.sol\";\n\nimport \"./lib/SignedZoneConstants.sol\";\n\n/**\n * @title  SignedZoneController\n * @author BCLeFevre\n * @notice SignedZoneController enables the deploying of SignedZones.\n *         SignedZones are an implementation of SIP-7 that requires orders to\n *         be signed by  an approved signer.\n *         https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md\n */\ncontract SignedZoneController is\n    SignedZoneControllerInterface,\n    SignedZoneControllerEventsAndErrors\n{\n    /**\n     * @dev The struct for storing signer info.\n     */\n    struct SignerInfo {\n        /// @dev If the signer is currently active.\n        bool active;\n        /// @dev If the signer has been active before.\n        bool previouslyActive;\n    }\n\n    // Properties used by the signed zone, stored on the controller.\n    struct SignedZoneProperties {\n        /// @dev Owner of the signed zone (used for permissioned functions)\n        address owner;\n        /// @dev Potential owner of the signed zone\n        address potentialOwner;\n        /// @dev The name for this zone returned in getSeaportMetadata().\n        string zoneName;\n        /// @dev The API endpoint where orders for this zone can be signed.\n        ///      Request and response payloads are defined in SIP-7.\n        string apiEndpoint;\n        /// @dev The URI to the documentation describing the behavior of the\n        ///      contract.\n        string documentationURI;\n        /// @dev The substandards supported by this zone.\n        ///      Substandards are defined in SIP-7.\n        uint256[] substandards;\n        /// @dev Mapping of signer information keyed by signer Address\n        mapping(address => SignerInfo) signers;\n        /// @dev List of active signers\n        address[] activeSignerList;\n    }\n\n    /// @dev Mapping of signed zone properties keyed by the Signed Zone\n    ///      address.\n    mapping(address => SignedZoneProperties) internal _signedZones;\n\n    /// @dev The EIP-712 digest parameters for the SignedZone.\n    bytes32 internal immutable _NAME_HASH = keccak256(bytes(\"SignedZone\"));\n    bytes32 internal immutable _VERSION_HASH = keccak256(bytes(\"1.0\"));\n    // prettier-ignore\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH = keccak256(\n          abi.encodePacked(\n            \"EIP712Domain(\",\n                \"string name,\",\n                \"string version,\",\n                \"uint256 chainId,\",\n                \"address verifyingContract\",\n            \")\"\n          )\n        );\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n\n    // Set the signed zone creation code as an immutable argument.\n    bytes32 internal immutable _SIGNED_ZONE_CREATION_CODE_HASH;\n\n    /**\n     * @dev Initialize contract\n     */\n    constructor() {\n        // Derive the signed zone creation code hash and set it as an\n        // immutable.\n        _SIGNED_ZONE_CREATION_CODE_HASH = keccak256(\n            type(SignedZone).creationCode\n        );\n    }\n\n    /**\n     * @notice Deploy a SignedZone to a precomputed address.\n     *\n     * @param zoneName    The name for the zone returned in\n     *                    getSeaportMetadata().\n     * @param apiEndpoint The API endpoint where orders for this zone can be\n     *                    signed.\n     * @param documentationURI The URI to the documentation describing the\n     *                         behavior of the contract.\n     *                    Request and response payloads are defined in SIP-7.\n     * @param salt        The salt to be used to derive the zone address\n     * @param initialOwner The initial owner to set for the new zone.\n     *\n     * @return derivedAddress The derived address for the zone.\n     */\n    function createZone(\n        string memory zoneName,\n        string memory apiEndpoint,\n        string memory documentationURI,\n        address initialOwner,\n        bytes32 salt\n    ) external override returns (address derivedAddress) {\n        // Ensure that an initial owner has been supplied.\n        if (initialOwner == address(0)) {\n            revert InvalidInitialOwner();\n        }\n\n        // Ensure the first 20 bytes of the salt are the same as the msg.sender.\n        if ((address(uint160(bytes20(salt))) != msg.sender)) {\n            // Revert with an error indicating that the creator is invalid.\n            revert InvalidCreator();\n        }\n\n        // Derive the SignedZone address from the deployer, salt and creation\n        // code hash.\n        derivedAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            salt,\n                            _SIGNED_ZONE_CREATION_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n\n        // TODO : Check runtime code hash to ensure that the zone is not already\n        // deployed.\n        // Revert if a zone is currently deployed to the derived address.\n        if (derivedAddress.code.length != 0) {\n            revert ZoneAlreadyExists(derivedAddress);\n        }\n\n        // Deploy the zone using the supplied salt.\n        new SignedZone{ salt: salt }();\n\n        // Initialize storage variable referencing signed zone properties.\n        SignedZoneProperties storage signedZoneProperties = _signedZones[\n            derivedAddress\n        ];\n\n        // Set the supplied intial owner as the owner of the zone.\n        signedZoneProperties.owner = initialOwner;\n        // Set the zone name.\n        signedZoneProperties.zoneName = zoneName;\n        // Set the API endpoint.\n        signedZoneProperties.apiEndpoint = apiEndpoint;\n        // Set the documentation URI.\n        signedZoneProperties.documentationURI = documentationURI;\n        // Set the substandard.\n        signedZoneProperties.substandards = [3];\n\n        // Emit an event signifying that the zone was created.\n        emit ZoneCreated(\n            derivedAddress,\n            zoneName,\n            apiEndpoint,\n            documentationURI,\n            salt\n        );\n\n        // Emit an event indicating that zone ownership has been assigned.\n        emit OwnershipTransferred(derivedAddress, address(0), initialOwner);\n    }\n\n    /**\n     * @notice Initiate zone ownership transfer by assigning a new potential\n     *         owner for the given zone. Once set, the new potential owner\n     *         may call `acceptOwnership` to claim ownership of the zone.\n     *         Only the owner of the zone in question may call this function.\n     *\n     * @param zone The zone for which to initiate ownership transfer.\n     * @param newPotentialOwner The new potential owner of the zone.\n     */\n    function transferOwnership(address zone, address newPotentialOwner)\n        external\n        override\n    {\n        // Ensure the caller is the current owner of the zone in question.\n        _assertCallerIsZoneOwner(zone);\n\n        // Ensure the new potential owner is not an invalid address.\n        if (newPotentialOwner == address(0)) {\n            revert NewPotentialOwnerIsZeroAddress(zone);\n        }\n\n        // Ensure the new potential owner is not already set.\n        if (newPotentialOwner == _signedZones[zone].potentialOwner) {\n            revert NewPotentialOwnerAlreadySet(zone, newPotentialOwner);\n        }\n\n        // Emit an event indicating that the potential owner has been updated.\n        emit PotentialOwnerUpdated(newPotentialOwner);\n\n        // Set the new potential owner as the potential owner of the zone.\n        _signedZones[zone].potentialOwner = newPotentialOwner;\n    }\n\n    /**\n     * @notice Clear the currently set potential owner, if any, from a zone.\n     *         Only the owner of the zone in question may call this function.\n     *\n     * @param zone The zone for which to cancel ownership transfer.\n     */\n    function cancelOwnershipTransfer(address zone) external override {\n        // Ensure the caller is the current owner of the zone in question.\n        _assertCallerIsZoneOwner(zone);\n\n        // Ensure that ownership transfer is currently possible.\n        if (_signedZones[zone].potentialOwner == address(0)) {\n            revert NoPotentialOwnerCurrentlySet(zone);\n        }\n\n        // Emit an event indicating that the potential owner has been cleared.\n        emit PotentialOwnerUpdated(address(0));\n\n        // Clear the current new potential owner from the zone.\n        _signedZones[zone].potentialOwner = address(0);\n    }\n\n    /**\n     * @notice Accept ownership of a supplied zone. Only accounts that the\n     *         current owner has set as the new potential owner may call this\n     *         function.\n     *\n     * @param zone The zone for which to accept ownership.\n     */\n    function acceptOwnership(address zone) external override {\n        // Ensure that the zone in question exists.\n        _assertZoneExists(zone);\n\n        // If caller does not match current potential owner of the zone...\n        if (msg.sender != _signedZones[zone].potentialOwner) {\n            // Revert, indicating that caller is not current potential owner.\n            revert CallerIsNotNewPotentialOwner(zone);\n        }\n\n        // Emit an event indicating that the potential owner has been cleared.\n        emit PotentialOwnerUpdated(address(0));\n\n        // Clear the current new potential owner from the zone.\n        _signedZones[zone].potentialOwner = address(0);\n\n        // Emit an event indicating zone ownership has been transferred.\n        emit OwnershipTransferred(zone, _signedZones[zone].owner, msg.sender);\n\n        // Set the caller as the owner of the zone.\n        _signedZones[zone].owner = msg.sender;\n    }\n\n    /**\n     * @notice Retrieve the current owner of a deployed zone.\n     *\n     * @param zone The zone for which to retrieve the associated owner.\n     *\n     * @return owner The owner of the supplied zone.\n     */\n    function ownerOf(address zone)\n        external\n        view\n        override\n        returns (address owner)\n    {\n        // Ensure that the zone in question exists.\n        _assertZoneExists(zone);\n\n        // Retrieve the current owner of the zone in question.\n        owner = _signedZones[zone].owner;\n    }\n\n    /**\n     * @notice Retrieve the potential owner, if any, for a given zone. The\n     *         current owner may set a new potential owner via\n     *         `transferOwnership` and that owner may then accept ownership of\n     *         the zone in question via `acceptOwnership`.\n     *\n     * @param zone The zone for which to retrieve the potential owner.\n     *\n     * @return potentialOwner The potential owner, if any, for the zone.\n     */\n    function getPotentialOwner(address zone)\n        external\n        view\n        override\n        returns (address potentialOwner)\n    {\n        // Ensure that the zone in question exists.\n        _assertZoneExists(zone);\n\n        // Retrieve the current potential owner of the zone in question.\n        potentialOwner = _signedZones[zone].potentialOwner;\n    }\n\n    /**\n     * @notice Returns the active signers for the zone.\n     *\n     * @param zone The zone to return the active signers for.\n     *\n     * @return signers The active signers.\n     */\n    function getActiveSigners(address zone)\n        external\n        view\n        override\n        returns (address[] memory signers)\n    {\n        // Ensure that the zone in question exists.\n        _assertZoneExists(zone);\n\n        // Retrieve storage region where the singers for the signedZone are\n        // stored.\n        SignedZoneProperties storage signedZoneProperties = _signedZones[zone];\n\n        // Return the active signers for the zone.\n        signers = signedZoneProperties.activeSignerList;\n    }\n\n    /**\n     * @notice Update the API endpoint returned by a zone.\n     *         Only the owner or an active signer of the supplied zone can call\n     *         this function.\n     *\n     * @param zone     The signed zone to update the API endpoint for.\n     * @param newApiEndpoint The new API endpoint.\n     */\n    function updateAPIEndpoint(address zone, string calldata newApiEndpoint)\n        external\n        override\n    {\n        // Ensure the caller is the owner or an active signer of the signed zone.\n        _assertCallerIsZoneOwnerOrSigner(zone);\n\n        // Retrieve storage region where the singers for the signedZone are\n        // stored.\n        SignedZoneProperties storage signedZoneProperties = _signedZones[zone];\n\n        // Update the API endpoint on the signed zone.\n        signedZoneProperties.apiEndpoint = newApiEndpoint;\n    }\n\n    /**\n     * @notice Add or remove a signer from the supplied zone.\n     *         Only the owner or an active signer of the supplied zone can call\n     *         this function.\n     *\n     * @param zone     The signed zone to update the signer permissions for.\n     * @param signer   The signer to update the permissions for.\n     * @param active   Whether the signer should be active or not.\n     */\n    function updateSigner(\n        address zone,\n        address signer,\n        bool active\n    ) external override {\n        // Ensure the caller is the owner or an active signer of the signed zone.\n        _assertCallerIsZoneOwnerOrSigner(zone);\n\n        // Retrieve storage region where the singers for the signedZone are\n        // stored.\n        SignedZoneProperties storage signedZoneProperties = _signedZones[zone];\n\n        // Validate signer permissions.\n        _assertSignerPermissions(signedZoneProperties, signer, active);\n\n        // Update the signer on the signed zone.\n        SignedZoneInterface(zone).updateSigner(signer, active);\n\n        // Update the signer information.\n        signedZoneProperties.signers[signer].active = active;\n        signedZoneProperties.signers[signer].previouslyActive = true;\n        // Add the signer to the list of signers if they are active.\n        if (active) {\n            signedZoneProperties.activeSignerList.push(signer);\n        } else {\n            // Remove the signer from the list of signers.\n            for (\n                uint256 i = 0;\n                i < signedZoneProperties.activeSignerList.length;\n\n            ) {\n                if (signedZoneProperties.activeSignerList[i] == signer) {\n                    signedZoneProperties.activeSignerList[\n                            i\n                        ] = signedZoneProperties.activeSignerList[\n                        signedZoneProperties.activeSignerList.length - 1\n                    ];\n                    signedZoneProperties.activeSignerList.pop();\n                    break;\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // Emit an event signifying that the signer was updated.\n        emit SignerUpdated(zone, signer, active);\n    }\n\n    /**\n     * @notice Derive the zone address associated with a salt.\n     *\n     * @param salt  The salt to be used to derive the zone address.\n     *\n     * @return derivedAddress The derived address of the signed zone.\n     */\n    function getZone(bytes32 salt)\n        external\n        view\n        override\n        returns (address derivedAddress)\n    {\n        // Derive the SignedZone address from deployer, salt and creation code\n        // hash.\n        derivedAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            salt,\n                            _SIGNED_ZONE_CREATION_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice External call to return the signing information, substandards,\n     *         and documentation about the zone.\n     *\n     * @return domainSeparator  The domain separator used for signing.\n     * @return zoneName         The name of the zone.\n     * @return apiEndpoint      The API endpoint for the zone.\n     * @return substandards     The substandards supported by the zone.\n     * @return documentationURI The documentation URI for the zone.\n     */\n    function getAdditionalZoneInformation(address zone)\n        external\n        view\n        override\n        returns (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        )\n    {\n        // Ensure the zone exists.\n        _assertZoneExists(zone);\n\n        // Return the zone's additional information.\n        return _additionalZoneInformation(zone);\n    }\n\n    /**\n     * @notice Internal call to return the signing information, substandards,\n     *         and documentation about the zone.\n     *\n     * @return domainSeparator  The domain separator used for signing.\n     * @return zoneName         The name of the zone.\n     * @return apiEndpoint      The API endpoint for the zone.\n     * @return substandards     The substandards supported by the zone.\n     * @return documentationURI The documentation URI for the zone.\n     */\n    function _additionalZoneInformation(address zone)\n        internal\n        view\n        returns (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        )\n    {\n        // Get the zone properties.\n        SignedZoneProperties storage signedZoneProperties = _signedZones[zone];\n\n        // Return the SIP-7 information.\n        domainSeparator = _domainSeparator(zone);\n        zoneName = signedZoneProperties.zoneName;\n        apiEndpoint = signedZoneProperties.apiEndpoint;\n        substandards = signedZoneProperties.substandards;\n        documentationURI = signedZoneProperties.documentationURI;\n    }\n\n    /**\n     * @dev Internal view function to get the EIP-712 domain separator. If the\n     *      chainId matches the chainId set on deployment, the cached domain\n     *      separator will be returned; otherwise, it will be derived from\n     *      scratch.\n     *\n     * @return The domain separator.\n     */\n    function _domainSeparator(address zone) internal view returns (bytes32) {\n        // prettier-ignore\n        return _deriveDomainSeparator(zone);\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return domainSeparator The derived domain separator.\n     */\n    function _deriveDomainSeparator(address zone)\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\n        bytes32 nameHash = _NAME_HASH;\n        bytes32 versionHash = _VERSION_HASH;\n\n        // Leverage scratch space and other memory to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Retrieve value at 0x80; it will also be replaced afterwards.\n            let slot0x80 := mload(Slot0x80)\n\n            // Place typehash, name hash, and version hash at start of memory.\n            mstore(0, typehash)\n            mstore(OneWord, nameHash)\n            mstore(TwoWords, versionHash)\n\n            // Place chainId in the next memory location.\n            mstore(ThreeWords, chainid())\n\n            // Place the address of the signed zone contract in the next memory location.\n            mstore(FourWords, zone)\n\n            // Hash relevant region of memory to derive the domain separator.\n            domainSeparator := keccak256(0, FiveWords)\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n\n            // Restore the value at 0x80.\n            mstore(Slot0x80, slot0x80)\n        }\n    }\n\n    /**\n     * @dev Private view function to revert if the caller is not the owner of a\n     *      given zone.\n     *\n     * @param zone The zone for which to assert ownership.\n     */\n    function _assertCallerIsZoneOwner(address zone) private view {\n        // Ensure that the zone in question exists.\n        _assertZoneExists(zone);\n\n        // If the caller does not match the current owner of the zone...\n        if (msg.sender != _signedZones[zone].owner) {\n            // Revert, indicating that the caller is not the owner.\n            revert CallerIsNotOwner(zone);\n        }\n    }\n\n    /**\n     * @dev Private view function to revert if the caller is not the owner or\n     *      an active signer of a given zone.\n     *\n     * @param zone The zone for which to assert ownership.\n     */\n    function _assertCallerIsZoneOwnerOrSigner(address zone) private view {\n        // Ensure that the zone in question exists.\n        _assertZoneExists(zone);\n\n        // Initialize storage variable referencing signed zone properties.\n        SignedZoneProperties storage signedZoneProperties = _signedZones[zone];\n\n        // Ensure the caller is the owner or an active signer of the signed zone.\n        if (\n            msg.sender != _signedZones[zone].owner &&\n            !signedZoneProperties.signers[msg.sender].active\n        ) {\n            // Revert, indicating that the caller is not the owner.\n            revert CallerIsNotOwnerOrSigner(zone);\n        }\n    }\n\n    /**\n     * @dev Private view function to revert if a given zone does not exist.\n     *\n     * @param zone The zone for which to assert existence.\n     */\n    function _assertZoneExists(address zone) private view {\n        // Attempt to retrieve a the owner for the zone in question.\n        if (_signedZones[zone].owner == address(0)) {\n            // Revert if no ownerwas located.\n            revert NoZone();\n        }\n    }\n\n    /**\n     * @dev Private view function to revert if a signer being added to a zone\n     *      is the zero address or the signer already exists, or the signer was\n     *      previously authorized.  If the signer is being removed, the\n     *      function will revert if the signer is not active.\n     *\n     * @param signedZoneProperties The signed zone properties for the zone.\n     * @param signer The signer to add or remove.\n     * @param active Whether the signer is being added or removed.\n     */\n    function _assertSignerPermissions(\n        SignedZoneProperties storage signedZoneProperties,\n        address signer,\n        bool active\n    ) private view {\n        // If the signer is being added...\n        if (active) {\n            // Do not allow the zero address to be added as a signer.\n            if (signer == address(0)) {\n                revert SignerCannotBeZeroAddress();\n            }\n\n            // Revert if the signer is already added.\n            if (signedZoneProperties.signers[signer].active) {\n                revert SignerAlreadyAdded(signer);\n            }\n\n            // Revert if the signer was previously authorized.\n            if (signedZoneProperties.signers[signer].previouslyActive) {\n                revert SignerCannotBeReauthorized(signer);\n            }\n        } else {\n            // Revert if the signer is not active.\n            if (!signedZoneProperties.signers[signer].active) {\n                revert SignerNotPresent(signer);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}